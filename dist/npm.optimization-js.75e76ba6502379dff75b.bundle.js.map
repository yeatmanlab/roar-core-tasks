{"version":3,"file":"npm.optimization-js.75e76ba6502379dff75b.bundle.js","mappings":"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","sources":["webpack://@bdelab/roar-levantecore-tasks/./node_modules/optimization-js/src/optimization.js"],"sourcesContent":["/**\n * Dimension of real type. \n * @constructor\n * @param {Number} low Lower bound of the values. Lower bound is inclusive.\n * @param {Number} high Upper inclusive bound of the values of dimension. \n */\nfunction Real(low, high){\n    this.low = low\n    this.high = high\n\n    /**\n     * Generate random uniformly distributed scalar sample from dimension space.\n     * @returns {Number} Sample value.\n     */\n    this.random_sample = function(){\n        /* Returns a uniformly sampled value from the space */\n        return Math.random()*(this.high - this.low) + this.low\n    }\n}\nmodule.exports.Real = function(low, high){\n    return new Real(low, high);\n}\n\n/**\n * Dimension of integer type. \n * @constructor\n * @param {Integer} low Lower bound of the values. Lower bound is inclusive.\n * @param {Integer} high Upper inclusive bound of the values of dimension. \n */\nfunction Integer(low, high){\n    this.low = low\n    this.high = high\n\n    /**\n     * Generate random uniformly distributed integer sample from dimension space.\n     * @returns {Number} Sample value.\n     */\n    this.random_sample = function(){\n        /* Returns a uniformly sampled value from the space */\n        var result = Math.random()*(this.high - this.low) + this.low\n        return Math.round(result)\n    }\n}\nmodule.exports.Integer = function(low, high){\n    return new Integer(low, high)\n}\n\n/**\n * Dimension of categorical type. Values of the dimension can be a mix of integer,\n * float, string and boolean values (tested) as well as it is expected that other\n * javascript types should work. \n * @constructor\n * @param {Array} categories A set of all feasible values for the dimension. For\n * example, it could be ['a', 1, 2.0, 'zazz', true].\n */\nfunction Categorical(categories){\n    this.categories = categories\n\n    /**\n     * Generate random uniformly distributed integer sample from dimension space.\n     * @returns {Number} Sample value.\n     */\n    this.random_sample = function(){\n        /* Returns a uniformly sampled value from the array of categorical values */\n        var N = this.categories.length\n        // index of value to be returned\n        var index = Math.round(Math.random()*(N-1))\n        return this.categories[index]\n    }\n}\nmodule.exports.Categorical = function(categories){\n    return new Categorical(categories)\n}\n\n/**\n * An object that represents a search space for an optimization problem. \n * Contains some helper methods, such as methods for automated sampling\n * of values from the space.\n * @constructor\n * @param {Number} dimensions An array of dimension descriptors that are \n * used to specify search space.\n */\nfunction Space(dimensions){\n    /*Stores a set of dimensions and provides convenience funcs */\n    this.dimensions = dimensions;\n\n    /**\n     * Sample n points from the search space at random. Sampling is done\n     * using functionality provided by the dimension classes themselves.\n     * @param {Integer} n Number of points to sample.\n     * @returns {Arrray} An array of vectors containing sampled values.\n     */\n    this.rsv = function(n){\n        /*Sample n points from space at random.*/\n        var X = []\n        for(var i = 0; i < n; i++){\n            var x = []\n            for(var dim of this.dimensions){\n                x.push(dim.random_sample())\n            }\n            X.push(x)\n        }\n        return X\n    }\n}\nmodule.exports.Space = function(dimensions){\n    return new Space(dimensions)\n}\n\n/**\n * A convenience function for conversion of Array of dimensions into a\n * single {@link Space} instance.\n * @param {Object} space_object Either an array of dimension objects, or\n * a {@link Space} instance.\n * @returns {Space} an instance of {@link Space} created out of the provided\n * objects.\n */\nmodule.exports.to_space = function(space_object){\n    // check if list of dimensions\n    if(space_object instanceof Array){\n        return module.exports.Space(space_object)\n    }\n\n    if(space_object instanceof Space){\n        return space_object\n    }\n    \n    throw 'Unknown space definition'\n}\n\n/**\n * A random optimization function. Sometimes competitive in practice\n * for hyperparameter tuning for instance. \n * @constructor\n * @param {Object} space An array of dimension descriptors that are \n * used to specify search space or an instance of {@link Space}.\n * @property {Array} X An array of arguments tried.\n * @property {Array} Y An array of function values observed. The \n * order corresponds to the order in arguments array.\n * @property {Array} best_x An argument that results in minimal objective\n * function value.\n * @property {Number} best_y Minimal objective value observed.\n * @property {Space} space Optimization space over which the optimization is done.\n */\nfunction RandomOptimizer(space){\n    this.space = module.exports.to_space(space)\n    this.X = []\n    this.Y = []\n    this.best_x = null\n    this.best_y = null\n\n    /**\n     * Get the next point or array of points to evaluate.\n     * @param {Number} n Specifies how many points should be provided by\n     * the optimizer algorithm to try in parallel. If specified, an array\n     * of points to evaluate is returned. If not, only a single point is \n     * returned verbatium.\n     */\n    this.ask = function(n=null){\n        if(n == null){\n            return this.space.rsv(1)[0]\n        }\n\n        // return array of points\n        return this.space.rsv(n)\n    }\n\n    /**\n     * Report back to the optimizer the points that were tried. Do not \n     * really need to do it for random sampling, but this is here for \n     * consistency with future more \"intelligent\" algorithms.\n     * @param {Array} X Array of observed points.\n     * @param {Array} Y Array of objective values corresponding to the \n     * points that were evaluated.\n     */\n    this.tell = function(X, Y){\n        for(var i = 0; i < X.length; i++){\n            if(this.best_y == null || Y[i] < this.best_y){\n                this.best_y = Y[i]\n                this.best_x = X[i]\n            }\n        }\n\n        // record observations\n        this.X = this.X.concat(X)\n        this.Y = this.Y.concat(Y)\n\n    }\n\n}\n\nmodule.exports.RandomOptimizer = function(space){\n    return new RandomOptimizer(space)\n}\n\n/**\n * Only Mutation Genetic Optimizer;\n * A class that performs optimization via random permutations to the best\n * found point thus far. Such approach in particular yields better results\n * than with crossover on the SigOpt's \"evalset\" set of problems.\n * @constructor\n * @param {Array} dimensions A list of dimensions or a {@link Space} object. \n * Describes the space of values over which a function will be optimized.\n * @param {Integer} n_random_starts Determines how many points wil be generated\n * initially at random. The points are not generated at random after this\n * number of evaluations has been reported to the optimizer.\n * @param {Number} mutation_rate A value in the range of (0.0, 1.0]\n * @property {Array} X An array of arguments tried.\n * @property {Array} Y An array of function values observed. The \n * order corresponds to the order in arguments array.\n * @property {Array} best_x An argument that results in minimal objective\n * function value.\n * @property {Number} best_y Minimal objective value observed.\n * @property {Space} space Optimization space over which the optimization is done.\n */\nfunction OMGOptimizer(dimensions, n_random_starts = 13, mutation_rate = 0.1) {\n\n    this.space = module.exports.to_space(dimensions);\n    this.n_random_starts = n_random_starts;\n    this.mutation_rate = mutation_rate;\n    this.n_random_starts_ = n_random_starts;\n    this.X = []\n    this.Y = []\n    this.best_x = null\n    this.best_y = null\n\n    /**\n    * Generates a boolean value at random. Is used for random mutations. \n    * @param {Number} p Probability of generation of true value \n    * @returns {Boolean} a randomly generated boolean value. \n    */\n    this.rnd = function (p = null) {\n\n        // by default use mutation rate as probability\n        if (p == null) {\n            p = this.mutation_rate;\n        }\n\n        if (Math.random() < p) {\n            return true;\n        }\n\n        return false\n\n    } // end rnd\n\n    /**\n    * Generates the next point to evaluate. Different points will be generated for multiple calls, which can be used for parallelisation of optimization. \n    * @returns {Array} a point to evaluate. \n    */\n    this.ask = function () {\n\n        // the usual initialization with random sampling from search space\n        if (this.n_random_starts_ > 0) {\n            return this.space.rsv(1)[0];\n        } // end random\n\n        finished = false;\n\n        while (!finished) {\n            // loop necessary to ensure that mutated value is generated\n\n            var result = []\n\n            var best_x = this.X[0]\n            var best_y = this.Y[0]\n\n            for (var i = 1; i < this.Y.length; i++) {\n                if (this.Y[i] < best_y) {\n                    best_x = this.X[i]\n                    best_y = this.Y[i]\n                }\n            }\n\n            for (var i = 0; i < this.space.dimensions.length; i++) {\n                var v = best_x[i];\n                var dim = this.space.dimensions[i];\n\n                if (dim instanceof Categorical && this.rnd()) {\n                    // select a new category here at random\n                    var sell = Math.round(Math.random() * (dim.categories.length - 1))\n\n                    v = dim.categories[sell]\n                    finished = true;\n\n                } // end handling categorical\n\n                if ((dim instanceof Real || (dim instanceof Integer)) && this.rnd()) {\n\n                    var low = dim.low;\n                    var high = dim.high;\n\n                    for (var pw = -16; pw <= 1; pw++) {\n\n                        if (this.rnd()) {\n                            finished = true;\n\n                            if (this.rnd(0.5)) { // determine the sign here\n                                diff = high - v\n                            } else {\n                                diff = low - v\n                            }\n\n                            v = v + diff * Math.pow(2, pw)\n\n                        } // end exp change\n\n                    }  // end handling the exponential change\n\n                    // clamp the dimension\n                    if (v < low) {\n                        v = low;\n                    }\n\n                    if (v > high) {\n                        v = high;\n                    }\n\n                    // round the dimension if it is integer\n                    if (dim instanceof Integer) {\n                        v = Math.round(v);\n                    }\n\n                } // end handling of the ordered type dimensions\n\n                result.push(v);\n\n            } // end dimension enumeration\n\n        } // end while loop of sampling\n\n        return result;\n\n    } // end of ask function \n\n    /**\n    *Function for reporting of the observed function values\n    * @param {Array} X Array of observed points.\n    * @param {Array} Y Array of objective values corresponding to the \n    * points that were evaluated.\n    */\n    this.tell = function (X, Y) {\n\n        for(var i = 0; i < X.length; i++){\n            this.n_random_starts_ -= 1\n\n            if(this.best_y == null || Y[i] < this.best_y){\n                this.best_y = Y[i]\n                this.best_x = X[i]\n            }\n        }\n\n        if(this.n_random_starts_ < 0){\n            this.n_random_starts_ = 0\n        }\n\n        // record observations\n        this.X = this.X.concat(X)\n        this.Y = this.Y.concat(Y)\n\n    } // end of tell function\n\n} // end of optimizer class\n\nmodule.exports.OMGOptimizer = function(dimensions, n_random_starts = 13, mutation_rate = 0.1){\n    return new OMGOptimizer(dimensions, n_random_starts, mutation_rate)\n}\n\n/**\n * Minimize a function using a random algorithm.\n * While naive, such approach is often surprisingly competitive\n * for hyperparameter tuning purposes. Internally uses {@link RandomOptimizer}\n * class to perform optimization.\n * @param {function} fnc Function to be minimized.\n * @param {Array} dimensions An array of dimensions, that describe a search space for minimization,\n * or an instance of {@link Space} object.\n * @param {Number} [n_calls=64] Function evaluation budget. The function will be evaluated for\n * at most this number of times.\n * @return {RandomOptimizer} The optimizer instance, that contains information about found minimum and explored arguments.\n*/\nfunction dummy_minimize (func, dimensions, n_calls=64){\n    var opt = module.exports.RandomOptimizer(dimensions);\n\n    for(var iter=0; iter < n_calls; iter++){\n        var x = opt.ask()\n        var y = func(x)\n        opt.tell([x], [y])\n    }\n\n    return opt\n}\nmodule.exports.dummy_minimize = dummy_minimize\n\n/**\n * Minimize a function using a random algorithm.\n * While naive, such approach is often surprisingly competitive\n * for hyperparameter tuning purposes. Internally uses {@link RandomOptimizer}\n * class to perform optimization.\n * @param {function} fnc Function to be minimized.\n * @param {Array} dimensions An array of dimensions, that describe a search space for minimization,\n * or an instance of {@link Space} object.\n * @param {Number} [n_calls=64] Function evaluation budget. The function will be evaluated for\n * at most this number of times.\n * @param {Integer} n_random_starts Determines how many points wil be generated\n * initially at random. The points are not generated at random after this\n * number of evaluations has been reported to the optimizer.\n * @param {Number} mutation_rate A value in the range of (0.0, 1.0]\n * @return {OMGOptimizer} The optimizer instance, that contains information about found minimum and explored arguments.\n*/ \nfunction rs_minimize (func, dimensions, n_calls=64, n_random_starts=13, mutation_rate=0.1){\n    var opt = module.exports.OMGOptimizer(\n        dimensions,\n        n_random_starts,\n        mutation_rate\n    );\n\n    for(var iter=0; iter < n_calls; iter++){\n        var x = opt.ask()\n        var y = func(x)\n        opt.tell([x], [y])\n    }\n\n    return opt\n}\nmodule.exports.rs_minimize = rs_minimize\n\n/**\n * Minimize an unconstrained function using zero order Powell algorithm.\n * @param {function} fnc Function to be minimized. This function takes \n * array of size N as an input, and returns a scalar value as output, \n * which is to be minimized.\n * @param {Array} x0 An array of values of size N, which is an initialization\n *  to the minimization algorithm.\n * @param {number} eps\n * @param {number} alpha scaling factor\n * @return {Object} An object instance with two fields: argument, which \n * denotes the best argument found thus far, and fncvalue, which is a\n * value of the function at the best found argument.\n*/\nmodule.exports.minimize_Powell = function (fnc, x0, eps = 1e-2, alpha = 0.001) {\n\n    var convergence = false;\n    var x = x0.slice(); // make copy of initialization\n    //var alpha = 0.001; // scaling factor\n\n    var pfx = Math.exp(10);\n    var fx = fnc(x);\n    var pidx = 1;\n    while (!convergence) {\n\n        var indicies = shuffleIndiciesOf(x);\n        convergence = true;\n\n        // Perform update over all of the variables in random order\n        for (var i = 0; i < indicies.length; i++) {\n\n            x[indicies[i]] += 1e-6;\n            var fxi = fnc(x);\n            x[indicies[i]] -= 1e-6;\n            var dx = (fxi - fx) / 1e-6;\n\n            if (Math.abs(dx) > eps) {\n                convergence = false;\n            }\n\n            x[indicies[i]] = x[indicies[i]] - alpha * dx;\n            fx = fnc(x);\n\n        }\n\n        // a simple step size selection rule. Near x function acts linear \n        // (this is assumed at least) and thus very small values of alpha\n        // should lead to (small) improvement. Increasing alpha would\n        // yield better improvement up to certain alpha size.\n        \n        alpha = pfx > fx ? alpha * 1.1 : alpha * 0.7;\n        pfx = fx;\n\n        pidx--;\n        if (pidx === 0) {\n            pidx = 1;\n        }\n\n    }\n\n    var solution = {};\n    solution.argument = x;\n    solution.fncvalue = fx;\n\n    return solution;\n\n};\n\n/**\n * Minimize an unconstrained function using first order gradient descent algorithm.\n * @param {function} fnc Function to be minimized. This function takes \n * array of size N as an input, and returns a scalar value as output, \n * which is to be minimized.\n * @param {function} grd A gradient function of the objective.\n * @param {Array} x0 An array of values of size N, which is an initialization\n *  to the minimization algorithm.\n * @return {Object} An object instance with two fields: argument, which \n * denotes the best argument found thus far, and fncvalue, which is a\n * value of the function at the best found argument.\n*/\nmodule.exports.minimize_GradientDescent = function (fnc, grd, x0) {\n    // fnc: function which takes array of size N as an input\n    // grd: gradient (array of size N) of function for some input\n    // x0: array or real numbers of size N; \n    // serves as initialization of algorithm.\n\n    // solution is a struct, with fields:\n    // argument: solution argument\n    // fncvalue: function value at found optimum\n    var x = x0.slice();\n\n    var convergence = false;\n    var eps = 1e-3;\n    var alpha = 0.01;\n\n    var pfx = fnc(x);\n\n    while (!convergence) {\n        var g = grd(x);\n        convergence = vect_max_abs_x_less_eps(g, eps);\n\n        if (convergence) {\n            break;\n        }\n\n        var repeat = true;\n\n        // a simple step size selection rule. Near x function acts linear \n        // (this is assumed at least) and thus very small values of alpha\n        // should lead to (small) improvement. Increasing alpha would\n        // yield better improvement up to certain alpha size.\n        \n        while (repeat) {\n            var xn = x.slice();\n            vect_x_pluseq_ag(xn, -alpha, g); // perform step\n            var fx = fnc(xn);\n\n            repeat = pfx < fx;\n            // this automatically selects step size \n            alpha = repeat ? alpha * 0.7 : alpha * 1.1;\n        }\n\n        x = xn;\n        pfx = fx;\n\n    }\n\n    var solution = {};\n    solution.argument = x;\n    solution.fncvalue = fx;\n    return solution;\n\n};\n\n/**\n * Minimize an unconstrained function using first order L-BFGS algorithm.\n * @param {function} fnc Function to be minimized. This function takes \n * array of size N as an input, and returns a scalar value as output, \n * which is to be minimized.\n * @param {function} grd A gradient function of the objective.\n * @param {Array} x0 An array of values of size N, which is an initialization\n *  to the minimization algorithm.\n * @return {Object} An object instance with two fields: argument, which \n * denotes the best argument found thus far, and fncvalue, which is a\n * value of the function at the best found argument.\n*/\nmodule.exports.minimize_L_BFGS = function (fnc, grd, x0) {\n    // fnc: function which takes array of size N as an input\n    // grd: gradient (array of size N) of function for some input\n    // x0: array or real numbers of size N; \n    // serves as initialization of algorithm.\n\n    // solution is a struct, with fields:\n    // argument: solution argument\n    // fncvalue: function value at found optimum\n    var x = x0.slice();\n\n    var eps = 1e-5; // max abs value of gradient component for termination\n    var alpha = 0.001; // initial step size\n    var m = 5; // history size to keep for Hessian approximation\n\n    var pfx = fnc(x);\n    var s = []; // this is needed for lbfgs procedure\n    var y = [];\n    var ro = [];\n\n    var g = grd(x);\n    var direction = g.slice();\n    var convergence = false;\n    while (!convergence) {\n\n        var xn = x.slice();\n        vect_x_pluseq_ag(xn, alpha, direction); // perform step\n        var fx = fnc(xn);\n        alpha = pfx < fx ? alpha * 0.5 : alpha * 1.2; // magic!\n\n        //  < ================= apply limited memory BFGS procedure ================= >\n        var gn = grd(xn);\n\n        if (vect_max_abs_x_less_eps(gn, eps)) {\n            break;\n        }\n\n        var dx = vect_a_minus_b(xn, x);\n        var dg = vect_a_minus_b(gn, g);\n\n        s.unshift(dx);\n        y.unshift(dg);\n        var tmp = 1 / (dot(dx, dg));\n        ro.unshift(tmp);\n\n        if (s.length > m) {\n            s.pop();\n            y.pop();\n            ro.pop();\n        }\n\n        var r = g.slice();\n        var a = new Array(s.length);\n\n        for (var i = 0; i < s.length; i++) {\n            var pi = 1 / (dot(s[i], y[i]));\n            a[i] = pi * dot(s[i], r);\n            vect_x_pluseq_ag(r, -a[i], y[i]);\n        }\n\n        // perform Hessian scaling\n        var scale = dot(dx, dg) / dot(dg, dg);\n        for (var i = 0; i < r.length; i++) {\n            r[i] = r[i] * scale;\n        }\n\n        for (var i = 0; i < s.length; i++) {\n            var j = s.length - i - 1;\n            var pj = 1 / (dot(s[j], y[j]));\n            var beta = pj * dot(y[j], r);\n            vect_x_pluseq_ag(r, (a[j] - beta), s[j]);\n        }\n        direction = r.slice();\n\n        //  < ================= apply limited memory BFGS procedure ================= >\n        \n        for (var i = 0; i < direction.length; i++) {\n            direction[i] = -direction[i];\n        }\n\n        pfx = fx;\n        x = xn;\n        g = gn;\n\n    }\n\n    var solution = {};\n    solution.argument = x;\n    solution.fncvalue = fx;\n    return solution;\n\n};\n\n/*module.exports.numerical_gradient = function (fnc, x) {\n    // can be used as for gradient check or its substitute. Gradient is approx. via forward difference\n    var grad = x.slice();\n    var fx = fnc(x);\n    var h = 1e-6; // step size\n\n    for (var i = 0; i < x.length; i++) {\n\n        // approximation using simple forward difference\n        x[i] += h;\n        var fxi = fnc(x);\n        x[i] -= h;\n\n        grad[i] = (fxi - fx) / h;\n    }\n    return grad;\n};*/\n\n/**\n * Shuffles indicies of arrray.\n * @ignore\n * @param {Array} array Array to shuffle.\n */\nfunction shuffleIndiciesOf (array) {\n    var idx = [];\n    for (var i = 0; i < array.length; i++) {\n        idx.push(i);\n    }\n    for (var i = 0; i < array.length; i++) {\n        var j = Math.floor(Math.random() * i);\n        var tmp = idx[i];\n        idx[i] = idx[j];\n        idx[j] = tmp;\n    }\n    return idx;\n};\n\n/**\n * Computes dot product.\n * @ignore\n * @param {Array} a First vector argument.\n * @param {Array} b Second vector argument.\n */\nfunction dot (a, b) {\n    var result = 0;\n    for (var i = 0; i < a.length; i++) {\n        result += a[i] * b[i];\n    }\n    return result;\n\n};\n\n/**\n * Substracts vectors.\n * @ignore\n * @param {Array} a First vector argument.\n * @param {Array} b Second vector argument.\n */\nfunction vect_a_minus_b (a, b) {\n    var result = new Array(a.length);\n    for (var i = 0; i < a.length; i++) {\n        result[i] = a[i] - b[i];\n    }\n    return result;\n\n};\n\n/**\n * Fixed step size updating value of x.\n * @ignore\n * @param {Array} x First vector argument.\n * @param {Number} a Step size.\n * @param {Array} g Gradient.\n */\nfunction vect_x_pluseq_ag (x, a, g) {\n    for (var i = 0; i < x.length; i++) {\n        x[i] = x[i] + a * g[i];\n    }\n\n    return x;\n\n};\n\n/**\n * Checks whether absolute values in a vector are greater than \n * some threshold.\n * @ignore\n * @param {Array} x Vector that is checked.\n * @param {Number} eps Threshold.\n */\nfunction vect_max_abs_x_less_eps (x, eps) {\n    // this procedure is used for stopping criterion check\n    for (var i = 0; i < x.length; i++) {\n        if (Math.abs(x[i]) >= eps) {\n            return false;\n        }\n    }\n    return true;\n};"],"names":["Real","low","high","this","random_sample","Math","random","Integer","result","round","Categorical","categories","N","length","index","Space","dimensions","rsv","n","X","i","x","dim","push","RandomOptimizer","space","module","exports","to_space","Y","best_x","best_y","ask","tell","concat","OMGOptimizer","n_random_starts","mutation_rate","n_random_starts_","rnd","p","finished","v","sell","pw","diff","pow","shuffleIndiciesOf","array","idx","j","floor","tmp","dot","a","b","vect_a_minus_b","Array","vect_x_pluseq_ag","g","vect_max_abs_x_less_eps","eps","abs","space_object","dummy_minimize","func","n_calls","opt","iter","y","rs_minimize","minimize_Powell","fnc","x0","alpha","convergence","slice","pfx","exp","fx","pidx","indicies","fxi","dx","solution","argument","fncvalue","minimize_GradientDescent","grd","repeat","xn","minimize_L_BFGS","s","ro","direction","gn","dg","unshift","pop","r","pi","scale","beta"],"sourceRoot":""}